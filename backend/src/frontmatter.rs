use serde::{Deserialize, Serialize};
use yaml_rust::{YamlEmitter, YamlLoader};

/// Errors generated by this crate
#[derive(Clone, Debug)]
enum FrontMatterError {
    MissingFrontMatter,
}

impl std::fmt::Display for FrontMatterError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            FrontMatterError::MissingFrontMatter => write!(f, "MissingFrontMatterError"),
        }
    }
}

impl std::error::Error for FrontMatterError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        None
    }
}

/// Deserialize a string containing front matter into a struct and the content of the string
pub fn deserialize<'a, T>(data: &'a str) -> Result<(T, &'a str), Box<dyn std::error::Error>>
where
    T: Deserialize<'a>,
{
    // We need frontmatter to be the first thing in the file
    if !data.starts_with("---") {
        return Err(Box::new(FrontMatterError::MissingFrontMatter));
    }

    // Use split to find the frontmatter content
    let split_data: Vec<&str> = data.split("---").collect();

    // Use the second item in the vector as the frontmatter
    let frontmatter = match split_data.get(1) {
        Some(&fm) => Ok(fm),
        None => Err(Box::new(FrontMatterError::MissingFrontMatter)),
    }?;
    let content = match split_data.get(2) {
        Some(&content) => content,
        None => "",
    };

    let docs = YamlLoader::load_from_str(frontmatter)?;

    // Parse the frontmatter
    Ok((serde_yaml::from_str(frontmatter.as_ref())?, content))
}

/// Serialize a struct and data into a string containing front matter
pub fn serialize<T: Serialize>(
    front_matter: T,
    content: &str,
) -> Result<String, Box<dyn std::error::Error>> {
    // Serialize the frontmatter
    let frontmatter = serde_yaml::to_string(&front_matter)?;

    // Return the result
    Ok(format!("{}\n---\n{}", frontmatter, content))
}

#[cfg(test)]
mod tests {
    //! These test cases are stolen from: https://github.com/azdle/rust-frontmatter/blob/master/src/lib.rs

    use super::*;
    use serde::{Deserialize, Serialize};

    #[derive(Serialize, Deserialize)]
    pub struct FM {
        pub title: String,
    }

    #[test]
    fn test_valid() {
        let test_string = "---\ntitle: Valid Yaml Test\n---\nsomething that's not yaml";

        let (matter, content) = deserialize::<FM>(&test_string).unwrap();
        assert_eq!(matter.title, "Valid Yaml Test");
        assert_eq!(content, "\nsomething that's not yaml");
    }

    #[test]
    fn test_invalid() {
        let test_string = "something that's not yaml even if it has\n---\nsome: yaml\n--";

        let result = deserialize::<FM>(&test_string);
        assert!(result.is_err());
    }
}
